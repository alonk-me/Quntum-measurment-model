r"""
Non-Hermitian evolution for monitored free fermions (number operator version).
==========================================================================

This module implements a simple free‑fermion correlation matrix simulator
subjected to both coherent ``XX`` hopping and an imaginary potential arising
from continuous measurements of the local number operators.  The simulator
evolves a ``2L×2L`` covariance matrix ``G`` in discrete time steps and
computes the resulting entropy production.  It is inspired by the
``LQubitCorrelationSimulator`` from the `Quntum-measurment-model` GitHub
repository but strips away the stochastic measurement back–action in favour
of a non-Hermitian effective Hamiltonian:

.. math::

    H_mathrm{eff} = J \sum_{j=0}^{L-2} \sigma^x_j \sigma^x_{j+1}
    \;\;\;\; -\frac{mathrm{i}\gamma}{2} \sum_{j=0}^{L-1} \hat{n}_j.

Here ``J`` is the nearest‑neighbour hopping and ``γ`` is the rate of
monitoring.  The number operator ``\hat{n}_j = c_j^\dagger c_j`` has
eigenvalues ``0`` (empty) and ``1`` (occupied).  Evolving with the above
non‑Hermitian Hamiltonian causes every creation and annihilation operator
to decay at rate ``γ/2``.  At the level of the covariance matrix this
translates into a simple linear differential equation

.. math::

    \dot{G} = -2 mathrm{i}[G,h] \;\; -\;\; \gamma\,G,

where ``h`` is the Bogoliubov–de Gennes Hamiltonian of the free fermion
chain and the last term encodes the imaginary potential.  For a small time
step ``dt`` we use the Euler discretisation

.. math::

    G \leftarrow G
      + dt\,\bigl(-2 mathrm{i}(G h - h G)\bigr)
      \;\; -\;\; dt\,\gamma\,G.

Starting from a product state ``|↓↓…↓⟩`` (no fermions), the simulator
accumulates an entropy production ``Q``.  Following the derivation in
``Entropy_Production_Quantum_Measurement.pdf`` the instantaneous entropy
production rate associated with the imaginary potential is

.. math::

    \frac{ mathrm{d}Q}{ mathrm{d}t} = \gamma \sum_{j=0}^{L-1}
      \bigl(1 - \langle \hat{n}_j \rangle\bigr).

In other words, empty sites contribute maximally to the entropy budget
while occupied sites contribute nothing.  In the Stratonovich
discretisation used here the contribution of a site is averaged between
its values before and after each time step.

This module exposes a single class, ``NonHermitianHatSimulator``, which can
be used to evolve the correlation matrix and measure the entropy
production.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Tuple
import numpy as np


@dataclass
class NonHermitianHatSimulator:
    """Simulate non‑Hermitian evolution with number‑operator monitoring.

    The system consists of ``L`` sites with nearest‑neighbour hopping
    generated by the ``XX`` Hamiltonian ``J σ^x_j σ^x_{j+1}`` (Jordan–Wigner
    equivalent to free fermion hopping).  Continuous monitoring of the
    occupation on each site gives rise to an imaginary potential
    ``-i γ/2 Σ n_j``.  The simulator propagates the ``2L×2L`` correlation
    matrix ``G`` under this effective Hamiltonian and records the total
    entropy production.  Open or periodic boundary conditions are
    supported.

    Parameters
    ----------
    L : int
        Number of sites in the chain.  The covariance matrix has dimension
        ``2*L``.
    J : float
        Coupling constant for the nearest‑neighbour ``XX`` Hamiltonian.
    gamma : float
        Monitoring rate of the number operators ``n_j``.  The imaginary
        potential is ``-i γ/2 Σ n_j``.
    dt : float, optional
        Time step for Euler integration.  For numerical accuracy, choose
        ``dt < 0.1 / max(J, gamma)``.  Default is ``0.001``.
    N_steps : int, optional
        Number of time steps for the simulation.  The total evolution time
        is ``T_total = dt * N_steps``.  Default is ``10000``.
    closed_boundary : bool, optional
        If ``True`` the chain has periodic boundary conditions; if ``False``
        open boundaries are used.  Default is ``False``.
    """

    L: int = 2
    J: float = 1.0
    gamma: float = 0.1
    dt: float = 0.0001
    N_steps: int = 10000
    closed_boundary: bool = False
    # Derived quantities initialised post construction
    T_total: float = field(init=False)
    h: np.ndarray = field(init=False, repr=False)
    G_initial: np.ndarray = field(init=False, repr=False)

    def __post_init__(self) -> None:
        # Input validation
        if self.L < 1:
            raise ValueError("L must be at least 1")
        if self.N_steps < 1:
            raise ValueError("N_steps must be at least 1")
        if self.gamma < 0:
            raise ValueError("gamma must be non‑negative")
        if self.dt <= 0:
            raise ValueError("dt must be positive")
        # Compute total evolution time
        self.T_total = self.dt * self.N_steps
        # Numerical stability warnings
        import warnings
        max_rate = max(abs(self.J), self.gamma)
        if self.dt * max_rate > 1.0:
            warnings.warn(
                f"Large dt*max(J,gamma) = {self.dt * max_rate:.3f} may cause "
                f"numerical instability. Consider dt < {0.5/max_rate:.4f}",
                UserWarning
            )
        if self.dt * max_rate < 0.001:
            warnings.warn(
                f"Very small dt*max(J,gamma) = {self.dt * max_rate:.6f} may require "
                f"many steps. Current T_total = {self.T_total:.4f}",
                UserWarning
            )
        # Build Bogoliubov–de Gennes Hamiltonian
        self.h = self._build_hamiltonian()
        # Construct initial correlation matrix corresponding to vacuum.
        # In the Nambu basis (c, c^†) the first L diagonal entries of G are
        # ⟨c_i^† c_i⟩ and the last L entries are ⟨c_i c_i^†⟩.  For the
        # vacuum one has ⟨c_i^† c_i⟩=0 and ⟨c_i c_i^†⟩=1.
        self.G_initial = np.zeros((2 * self.L, 2 * self.L), dtype=complex)
        for i in range(self.L, 2 * self.L):
            self.G_initial[i, i] = 1.0 + 0.0j

    def _build_hamiltonian(self) -> np.ndarray:
        """Construct the 2L×2L single‑particle Hamiltonian ``h``.

        The matrix has four L×L blocks.  The off–diagonal blocks encode
        particle–hole mixing from the Jordan–Wigner mapping.  Only the
        super‑diagonal is populated to represent nearest‑neighbour coupling.

        Returns
        -------
        h : numpy.ndarray
            The 2L×2L complex matrix defining coherent evolution.
        """
        L = self.L
        J = self.J
        h11 = np.zeros((L, L), dtype=complex)
        h12 = np.zeros((L, L), dtype=complex)
        h21 = np.zeros((L, L), dtype=complex)
        h22 = np.zeros((L, L), dtype=complex)
        # Fill off‑diagonal entries for nearest neighbours
        for i in range(L - 1):
            h11[i, i + 1] = -J
            h12[i, i + 1] = -J
            h21[i, i + 1] = +J
            h22[i, i + 1] = +J
        # Periodic boundary conditions: connect last to first
        if self.closed_boundary and L > 1:
            i = L - 1
            j = 0
            h11[i, j] = -J
            h12[i, j] = -J
            h21[i, j] = +J
            h22[i, j] = +J
        # Assemble full BdG matrix
        top = np.hstack((h11, h12))
        bottom = np.hstack((h21, h22))
        return np.vstack((top, bottom))

    def _hamiltonian_step(self, G: np.ndarray) -> np.ndarray:
        """One Euler step of coherent (unitary) evolution under ``h``."""
        comm = G @ self.h - self.h @ G
        return G + (-2.0j * self.dt) * comm

    def _nonhermitian_step(self, G: np.ndarray) -> np.ndarray:
        """One Euler step of imaginary‑potential evolution.

        The effective non‑Hermitian contribution ``-i γ/2 Σ n_j`` produces
        the evolution given by:
        δG = dt γ [(G σ^z G) - 1/2(σ^z G + G σ^z)]
        where σ^z = diag{1,...,1,-1,...,-1} with L ones and L minus ones.
        """
        # Construct sigma_z = diag(1,...,1,-1,...,-1)
        sigma_z = np.diag(np.concatenate([np.ones(self.L), -np.ones(self.L)]))
        
        # Compute the update: δG = dt γ [(G σ^z G) - 1/2(σ^z G + G σ^z)]
        term1 = G @ sigma_z @ G
        term2 = 0.5 * (sigma_z @ G + G @ sigma_z)
        delta_G = self.dt * self.gamma * (term1 - term2)
        
        return G + delta_G

    def _compute_n_values(self, G: np.ndarray) -> np.ndarray:
        """Compute occupations ``⟨n_i⟩`` from the covariance matrix.

        The occupations are the real parts of the first L diagonal entries
        of ``G``.  They lie in [0,1] and measure the probability of
        finding a fermion at each site.
        """
        return np.real(np.diag(G)[: self.L])

    def simulate_trajectory(
        self, 
        return_G_final: bool = True
    ) -> Tuple[float, np.ndarray] | Tuple[float, np.ndarray, np.ndarray]:
        """Propagate a single trajectory and compute entropy production.

        The correlation matrix is initialised to the vacuum and then
        updated for ``N_steps`` discrete time increments of size ``dt``.
        At each step the state is evolved under the coherent Hamiltonian
        followed by the imaginary potential.  The occupations before and
        after the step are used to compute the Stratonovich average ``n̄_i``.
        The entropy increment for the step is then

        .. math::

            \Delta Q = \gamma\, dt\,\sum_{i=0}^{L-1}
              \bigl(1 - \bar{n}_i\bigr).

        The total evolution time is ``T_total = dt * N_steps``.

        Parameters
        ----------
        return_G_final : bool, optional
            If True, returns the final correlation matrix G_final as third
            return value. If False, returns only (Q_total, n_traj) for
            backward compatibility. Default is True.

        Returns
        -------
        Q_total : float
            The total entropy production accumulated over the trajectory.
        n_traj : numpy.ndarray
            An array of shape ``(N_steps+1, L)`` recording the occupations at
            each time step, including the initial state.
        G_final : numpy.ndarray, optional
            The final correlation matrix of shape ``(2L, 2L)`` after all
            evolution steps, representing the steady state. Only returned
            if return_G_final=True.
        """
        G = self.G_initial.copy()
        n_traj = np.zeros((self.N_steps + 1, self.L), dtype=float)
        # initial occupations
        n_traj[0] = self._compute_n_values(G)
        Q = 0.0
        for step in range(self.N_steps):
            n_before = n_traj[step]
            # Hamiltonian evolution
            G = self._hamiltonian_step(G)
            # Imaginary potential
            G = self._nonhermitian_step(G)
            # Symmetrise and clip diagonal entries to preserve Hermiticity and
            # valid occupations.  Numerical integration may introduce small
            # anti‑hermitian components; symmetrisation suppresses them.
            G = 0.5 * (G + G.conj().T)
            diag = np.diag(G).copy()
            diag_clipped = np.clip(np.real(diag), 0.0, 1.0)
            for i in range(2 * self.L):
                G[i, i] = diag_clipped[i] + 0.0j
            # compute occupations after update
            n_after = self._compute_n_values(G)
            n_traj[step + 1] = n_after
            # Stratonovich average for entropy production
            n_avg = 0.5 * (n_before + n_after)
            Q += self.gamma * self.dt * np.sum(1.0 - 2*n_avg)
        
        if return_G_final:
            return Q, n_traj, G
        else:
            return Q, n_traj
