#!/usr/bin/env python3
"""
Check what parameter grid is being generated by run_ninf_scan.py
"""

import numpy as np

# Reproduce the grid from run_ninf_scan.py
print("="*60)
print("PARAMETER GRID ANALYSIS")
print("="*60)

# Global coverage: log-spaced
# Updated to match run_ninf_scan.py: starting at 0.4 for g_min = 0.1
gamma_log = np.logspace(np.log10(0.4), 2, 80)  # 0.4 to 100 (g: 0.1 to 25)

# Critical region: g ∈ [0.6, 1.4], linear in g
g_critical = np.linspace(0.6, 1.4, 120)
gamma_critical = 4.0 * g_critical

# Combine and sort
gamma_grid = np.unique(np.concatenate([gamma_log, gamma_critical]))

print(f"\nTotal unique gamma values: {len(gamma_grid)}")
print(f"Range: [{gamma_grid.min():.6e}, {gamma_grid.max():.6e}]")

print(f"\n{'='*60}")
print("FIRST 10 GAMMA VALUES:")
print(f"{'='*60}")
for i, gamma in enumerate(gamma_grid[:10]):
    g = gamma / 4.0
    print(f"  {i+1:3d}. γ={gamma:10.6f}, g={g:10.6f}")

print(f"\n{'='*60}")
print("CRITICAL REGION (g near 1):")
print(f"{'='*60}")
count = 0
for i, gamma in enumerate(gamma_grid):
    g = gamma / 4.0
    if 0.9 <= g <= 1.1:
        print(f"  {i+1:3d}. γ={gamma:10.6f}, g={g:10.6f}")
        count += 1
print(f"Total in critical region: {count}")

print(f"\n{'='*60}")
print("LAST 10 GAMMA VALUES:")
print(f"{'='*60}")
for i, gamma in enumerate(gamma_grid[-10:]):
    g = gamma / 4.0
    idx = len(gamma_grid) - 10 + i + 1
    print(f"  {idx:3d}. γ={gamma:10.6f}, g={g:10.6f}")

print(f"\n{'='*60}")
print("L VALUES:")
print(f"{'='*60}")
L_values = [9, 17, 33, 65, 129, 256]
print(f"L range: {L_values}")
print(f"Total runs: {len(gamma_grid)} gamma × {len(L_values)} L = {len(gamma_grid) * len(L_values)}")

# Calculate adaptive max_steps for extreme cases
print(f"\n{'='*60}")
print("ADAPTIVE MAX_STEPS EXAMPLES:")
print(f"{'='*60}")

def get_adaptive_max_steps(L, gamma, dt=0.001):
    base_steps = int(40.0 / gamma / dt)
    size_factor = 1.0 + 0.3 * np.log(L / 9.0)
    max_steps = int(base_steps * size_factor)
    max_steps = max(50000, min(max_steps, 3000000))
    return max_steps

test_cases = [
    (9, gamma_grid[0]),      # Smallest L, smallest gamma
    (9, 1.0),                # Smallest L, gamma=1
    (9, gamma_grid[-1]),     # Smallest L, largest gamma
    (129, gamma_grid[0]),    # Large L, smallest gamma
    (129, 1.0),              # Large L, gamma=1
    (256, gamma_grid[0]),    # Largest L, smallest gamma
]

for L, gamma in test_cases:
    max_steps = get_adaptive_max_steps(L, gamma)
    print(f"  L={L:3d}, γ={gamma:8.4f} → max_steps={max_steps:8d} ({max_steps*0.001:.1f}s @ dt=0.001)")

print(f"\n{'='*60}")
